#+BEGIN_COMMENT
| 名称       | 简述         | 取值               |
|------------+--------------+--------------------|
| TITLE      | 标题         |                    |
|------------+--------------+--------------------|
| LAYOUT     | hexo排版模式 | post               |
|------------+--------------+--------------------|
| CATEGORIES | 分类仓库     | IDE, gnu, protocal |
|            |              | system, tool,emacs |
|------------+--------------+--------------------|
| TAGS       | 标签         |                    |
|------------+--------------+--------------------|
#+END_COMMENT

#+TITLE: 常见网络编程
#+LAYOUT: post
#+CATEGORIES: protocol
#+TAGS: socket, epoll

socket相关网络编程
#+HTML: <!-- more -->
* 网络编程
  关注点:
  1. 阻塞问题
  2. 粘包问题 (tcp特有 -- 有边界但无法确认)
  3. 队列问题
     多线程处理
** socket
*** Socket由来
    socket是应用层 与 传输层和网络层之间的一个抽象层
    它的出现是为了简化网络进程通信
*** 函数讲解
    1. socket(domain, socket_type, protol)
       domain
       socket_type
       protol
       socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引.
    2. bind(fd, sockaddr*, len)
       fd:        socket()中的文件表指针的索引
       sockaddr:  地址, 端口
       len:       sockaddr的长度
       <1> 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转
           比如
            AF_INET   sockaddr_in
            AF_INET6  sockaddr_in6
            AF_UNIX   sockaddr_un
           这几种结构体都与sockaddr可互转(字节对齐blabla)
       bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充
       因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要
       使用bind()
    3. connet(fd, sockaddr*, len)
       连接到其他scokaddr
    4. listen(fd, iMaxNum)
       一般只在server开启listen(), 监听指定的端口信息
    5. accept()
       accept()会造成阻塞.
       它会将listen()中的sockaddr进行处理
       处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址
       但是fd_connect仅仅是用来传输数据的
    6. recv(fd, msg)  send(fd, msg)
       至accetp()时候, 一切操作就和在本地上操作一样,
       所以这里的recv() 和 send()操作与本机上的文件操作是一样的
    7. close(fd)  shutdown(fd, type)
       linux一切皆是file原则, fd可以关闭

*** 头文件
     1. usr/include/x86_64-linux-gnu/sys/socket.h
	结构体
        sockaddr
	函数
        socket() connect() send() recv() close()
	socket() bind()    lisent()  accept() recv() send() close()
        g++的默认目录中已经包含了sys/的上层目录
     2. usr/include/netinet/in.h
	结构体
        AF_INET  中的 sockaddr_in
	AF_INET6 中的 sockaddr_in6
	AF_UNIx  中的 sockaddr_un
     3. user/include/arpa/inet.h
	函数
	htons()
	inet_addr()

*** Unix Program 卷一 心得
    整本书讲了二部分,
    一为如何正确的创建socket fd进程文件表
    二为如何设计开发一个健壮的服务器|客户端程序

**** socket fd
     进程文件表主要有

     | 名称 | 说明                                      | 备注                 |
     |------+-------------------------------------------+----------------------|
     | fd   | 文件描述符, 表的索引                      |                      |
     |------+-------------------------------------------+----------------------|
     | host | 1. 域名(DNS /etc/hosts) 2. ip地址         | 兼容Ipv4 Ipv6是难点  |
     |------+-------------------------------------------+----------------------|
     | 服务 | 1. 服务名称(/etc/services) 2. 端口        |                      |
     |------+-------------------------------------------+----------------------|
     | 协议 | 1. 传输层(/etc/protol) 2. 网络层          | 链路层用到的比较少   |
     |------+-------------------------------------------+----------------------|
     | 网络 | 1. 网络名称?(DNS /etc/networks) 2. ip地址 | 谁会使用到这些信息?? |
     |------+-------------------------------------------+----------------------|

     期间用到的函数主要有
     注: 尽量使用ipv4, ipv6通用的函数
     1. 流程函数
	socket() bind() listen() connect() accept()等
     2. 字节处理函数
	处理大小字节序 htons() htonl() ntohs() ntohl()
	处理域名与十分数字 getaddrinfo()  getnameinfo()
     3. 处理sockaddr结构体的函数
	getsockname() 返回local fd
	getpeername() 返回remote fd

**** 健壮的server | client程序
     需要掌握:
     1. 各协议的细节
        比如tcp连接的三次握手, 四次close等
     2. 操作系统缓冲区机制
	主要影响 read() write()等读写操作
     3. 进程, 线程, I/O操作 和 协议的结合

** socket问题
   1. 阻塞
      阻塞影响了并发
      方案:
      1) select
      2) poll
      3) epoll
      4) 多线程 -- 异步问题
      5) 多进程 -- close问题
   2. 粘包
      方案:
      1) 限制发送大小
      2) 每个消息增加长度标识
   3. 同步 异步
      client端, 与server关系不大
      同步: 等待结果返回; 返回之前无法操作
      异步: 等待结果返回, 返回之前可以自由活动
** I/O模型
   [[https://mp.weixin.qq.com/s?src=11&timestamp=1565671711&ver=1787&signature=-mLkqQr803XDHb4f3aj9Lf1dJl8uVOV9fCCMMTzs0zSuOYH-qof7nsYCdgho1XLdPQYQP6QL5-WHtI6g-MD9xIsJcuxzdH*idpCZqtzl85r9D4C3XRRuOcCXqLKDzi-i&new=1][强烈建议阅读]]
   (链接过期, 直接搜狗搜索epoll, "epoll本质"即是)
   1. 阻塞式      
   2. 非阻塞
   3. 复合 -- select
   4. 复合 -- poll
   5. 复合 -- epoll (linux特有)
     
** epoll使用
*** epoll本身为我们处理了什么
    1. 之前socket::recv()时, 导致我们的进程阻塞
    2. 现在socket::recv()时, 使epoll阻塞; epoll中断时, 告之进程
*** 有了epoll我们还需要处理什么
    1. 创建epoll对象
    2. 添加检视的fd对象 -- op, epoll_event 
    3. 检测是否有中断, 然后处理
