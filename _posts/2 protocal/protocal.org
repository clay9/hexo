#+TITLE: 乱七八糟的协议合集
#+LAYOUT: post
#+CATEGORIES: protocal
#+TAGS: 字符编码, 大小字节序, ip, socket

协议太多, 不好分类, 真是乱七八糟
#+HTML: <!-- more -->
* 简单协议
** 字符编码
   写入内存过程:
   符号  --> 根据符号表(编码表), 找到符号的value  --> 根据实现算法(utf-8等), 计算出在内存中的值  --> 内存值

   解析过程:
   内存值 --> 根据算法, 计算出符号的value  --> 根据符号表, 找到value对应的符号 --> 符号
*** 编码小知识
   ios-8859-1 为http上所使用的编码
  
   我在gitlab上面下载的代码虽然最原始是GBK编码（win下），
   下载到mac后 通过file -I 会被识别为iso-8859-1, 就是因为是http协议下载的。
   所以转换为mac下可以使用的时候，做法应该是：
   iconv -f GBK -t UTF-8  file > file2

*** ASCII && Unicode
    由来
    ASCII码 -- 保存英文以及一些特殊控制字符 byte即2^8=256个符号

    Unicode -- 1. ASCII符号表只能有256个符号, 不够其他国家使用, 比如汉字有10W+
               2. 各个国家符号表(key)对应的value不同, 导致web通信困难(乱码), 为了统一, unicode出现
*** Unicode && utf-8
    Unicod只是符号表, 其内部类似于这样
    | 符号 | Value |
    |------+-------|
    | 严   |  4E25 |
    |------+-------|

    即我们的汉字"严" 对应的Unicode Value就是 4E25
    但Unicode只是规定了符号表的map(key, value),
    并没有规定value在内存中的存储形式,
    比如little endian中"严"是25 4E 第一个字节为25, 第二个字节为4E
    而  big    endian中则是  4E 25
    除了大小字节序问题, 4E 25的如何实现也有非常多的方法
    常见的有utf-8  utf-16等等

    所以utf-8只是实现Unicode的一种方式
    比较重要的一点是, 为了兼容ASCII,
    ASCII对应的符号value, 在ASCII与utf-8中一致(即英文与控制符号一致)
*** ASCII && Unicode转换
    这个转换确实纠结了我很久

    转换的复杂性在于
    1. 字节长度问题
       ASCII码的value是一个BYTE, 其value在内存中的实现也是一个byte
       Unicode的value是二个byte, 其Value在内存中的实现(utf-8)有1-5个byte

       字节长度不同, 导致我们需要在char* 和 wchar_t*间转换
    2. 编码格式
       注: 其实1应该也属于编码格式

       因为ASCII 和 Unicode(自身)之间的实现方式差异很大, 在其中转换的时候要非常熟悉各种编码实现的原理

    为了解决2个问题, 可以考虑一下2个函数, 虽然是windows下的:
    MultiByteToWideChar和WideCharToMultiByte

** 大小字节序
   对于多字节, 比如 AE FF

   Big—Endian 大字节
   如果在内存中
   0x 0000 0001 AE
   0x 0000 0002 FF
   即内存中的低位保存的是高字节 则为Big-Endian

   little-Endian 小字节
   如果在内存中
   0x 0000 0001 FF
   0x 0000 0002 AE
   即内存中的低位保存的是低字节 则为little-Endian

   网络上的传输为大字节序
   所以在host传入到internet时候, 比如socket, 应该将字节序转换

** ip地址详解
   1. 主机host的数量        决定了    选择 A类 B类 或者C类地址
   2. hosts的划分, 即子网   决定了    掩码的值
   3. 掩码的值              决定了    ip地址的网络id 与 主机id


   A类的掩码 为 255.0.0.0
   B类的掩码 为 255.255.0.0
   C类的掩码 为 255.255.255.0

   通过A类掩码 计算出 所能承载的host数量n,
                      按ip从0.0.0.0开始, 数到host数量n, 计算出A类ip地址范围

   通过B类掩码 计算出 所能承载的host数量m
                      按A类广播地址+1开始, 数到m, 计算出B类ip地址范围

   通过C类掩码 计算出 所能承载的host数量x
                      按B类广播地址+1开始, 数到x, 计算出C类ip地址范围


   子网的第一个ip地址 和最后一个ip地址有特殊含义
   第一个ip地址为  本机地址??????
   最后一个ip地址为广播地址
   这2个地址 被设计用来做其他事情, 设计的时候不应该考虑吧进去

** socket
   1. [ ] socket的缺点
      1) 队列问题
	 只能一个个处理, 导致后面的只能排队等待

   2. [ ] socket的进阶
      1) 多线程 -- 异步问题
      2) 多进程 -- close问题
      3) 半阻塞

*** Socket由来
    socket是应用层 与 传输层和网络层之间的一个抽象层
    它的出现是为了简化网络进程通信
*** 函数讲解
    1. socket(domain, socket_type, protol)
       domain
       socket_type
       protol
       socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引.
    2. bind(fd, sockaddr*, len)
       fd:        socket()中的文件表指针的索引
       sockaddr:  地址, 端口
       len:       sockaddr的长度
       <1> 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转
           比如
            AF_INET   sockaddr_in
            AF_INET6  sockaddr_in6
            AF_UNIX   sockaddr_un
           这几种结构体都与sockaddr可互转(字节对齐blabla)
       bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充
       因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要
       使用bind()
    3. connet(fd, sockaddr*, len)
       连接到其他scokaddr
    4. listen(fd, iMaxNum)
       一般只在server开启listen(), 监听指定的端口信息
    5. accept()
       accept()会造成阻塞.
       它会将listen()中的sockaddr进行处理
       处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址
       但次fd_connect仅仅是用来传输数据的
    6. recv(fd, msg)  send(fd, msg)
       至accetp()时候, 一切操作就和在本地上操作一样,
       所以这里的recv() 和 send()操作与本机上的文件操作是一样的
    7. close(fd)  shutdown(fd, type)
       linux一切皆是file原则, fd可以关闭

*** 头文件
     1. usr/include/x86_64-linux-gnu/sys/socket.h
	结构体
        sockaddr
	函数
        socket() connect() send() recv() close()
	socket() bind()    lisent()  accept() recv() send() close()
        g++的默认目录中已经包含了sys/的上层目录
     2. usr/include/netinet/in.h
	结构体
        AF_INET  中的 sockaddr_in
	AF_INET6 中的 sockaddr_in6
	AF_UNIx  中的 sockaddr_un
     3. user/include/arpa/inet.h
	函数
	htons()
	inet_addr()

*** Unix Program 卷一 心得
    整本书讲了二部分,
    一为如何正确的创建socket fd进程文件表
    二为如何设计开发一个健壮的服务器|客户端程序

**** socket fd
     进程文件表主要有

     | 名称 | 说明                                      | 备注                 |
     |------+-------------------------------------------+----------------------|
     | fd   | 文件描述符, 表的索引                      |                      |
     |------+-------------------------------------------+----------------------|
     | host | 1. 域名(DNS /etc/hosts) 2. ip地址         | 兼容Ipv4 Ipv6是难点  |
     |------+-------------------------------------------+----------------------|
     | 服务 | 1. 服务名称(/etc/services) 2. 端口        |                      |
     |------+-------------------------------------------+----------------------|
     | 协议 | 1. 传输层(/etc/protol) 2. 网络层          | 链路层用到的比较少   |
     |------+-------------------------------------------+----------------------|
     | 网络 | 1. 网络名称?(DNS /etc/networks) 2. ip地址 | 谁会使用到这些信息?? |
     |------+-------------------------------------------+----------------------|

     期间用到的函数主要有
     注: 尽量使用ipv4, ipv6通用的函数
     1. 流程函数
	socket() bind() listen() connect() accept()等
     2. 字节处理函数
	处理大小字节序 htons() htonl() ntohs() ntohl()
	处理域名与十分数字 getaddrinfo()  getnameinfo()
     3. 处理sockaddr结构体的函数
	getsockname() 返回ocal fd
	getpeername() 返回remote fd
	等

**** 健壮的server | client程序
     需要掌握:
     1. 各协议的细节
        比如tcp连接的三次握手, 四次close等
     2. 操作系统缓冲区机制
	主要影响 read() write()等读写操作
     3. 进程, 线程, I/O操作 和 协议的结合

