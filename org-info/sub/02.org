#+TITLE: 服务端
#+INFOJS_OPT: home:http://wcq.fun
#+INFOJS_OPT: view:info toc:t ltoc:t mouse:underline buttons:nil


* PROJECT 框架分离 && 多游戏支持
  target: 分布式, 多游戏支持, frmae与sub分离
** DONE 分布式
   CLOSED: [2019-08-05 Mon 14:24]
   - [2019-08-05 Mon] [done]
*** 架构图
    #+BEGIN_EXAMPLE  

    	   lob.cfg   +-------+ 	连接记录      +--------+  连接记录      +--------+
   --- 	   <------   | lobby | 	---------->   | gate   |  ---------->	| client |
  /   \	   ------>   +-------+ 	<----------   +--------+  <----------  	+--------+
 /     \   连接记录   ^  |   gate.cfg gameID推算          配置文件	 ^    |
 | DB  |	      |	 v						 |    |
 \     /             +-------+	 连接记录     +--------+    连接记录  	 |    |
  \   /	      	     |  game | 	---------->   | gate   |  ---------------+    |
   ---	       	     +-------+ 	<----------   +--------+  <-------------------+
	    	    /	      gate.cfg gameID推算           lobby告之
	   	   /
       	   	  /
		 /
       	   1. game  -> lobby: game.cfg
	   2. lobby -> game : 连接记录

     #+END_EXAMPLE

*** cfg问题
    1. socket发送消息会通过哪个网卡发送 
       测试 -- 局域网
       1) lobby, game在一台服务器
	  现象: game.cfg.lobbyIP   = 127.0.0.1
          结果: lobbyserver.gameIP = 127.0.0.1
       2) lobby game在一台服务器
	  现象: game.cfg.lobbyIP   = 192.168.0.120
	  结果: lobbyserver.gameIP = 192.168.0.120
       3) lobby, game不在一台服务器
	  现象: game.cfg.lobbyIP   = 192.168.0.253
	  结果: lobbyserver.gameIP = 192.168.0.120
       测试 -- Internet网
       1) lobby, game在一台服务器
	  未测试
       2) lobby, game不在一台服务器
	  未测试

       结论:
       game连接lobby的ip地址, 决定了game使用哪个网卡发送
       1) lobbyIPInGame = 127.0.0.1 则使用lo发送
       2) lobbyIPInGame = 局域网ip, 则使用局域网网卡
       3) lobbyIPInGame = internet, 则使用外网网卡
    2. 所以cfg配置如下:
       测试的话, 一般在局域网,  则选用局域网IP
       运营的话, 肯定在internet,则选用外网IP

*** 端口生成规则                                                  :TODOLATER:
    [[file:~/code/company/SystemModule/LobbyServer/GameCtrl.h::GeneratePort2Game][具体实现]]
    同一服务器, 各进程(lobby,game,gate)端口号必须唯一

    方案:
    1. [X] 由一台协调服统一分配
       采用:
       1) game启动时候, 向lobby申请端口, lobby返回给game
       2) [lobby, gmae] 与 gate的端口关系为固定值
	  gateport = server.port + 4100
    2. [ ] 各个进程, 读取数据库, 然后自动生成
       舍弃: game现在不与DB通信, 修改起来太麻烦

    遗留问题:
    1. 多网卡下, lobby无法识别game是否与自己在同一台服务器; 容易导致端口分配失败;
    2. lobby生成port的函数是根据gameid写死的
       port = (kindid << 8) + nodeid + 2000
       之所以写死, 是因为 -- 我也忘记了 :)

** DONE 多游戏支持
   CLOSED: [2019-08-05 Mon 14:25]
   - [2019-08-05 Mon] [done]
*** 房间号生成规则
    
    多游戏支持, 对于相同的kind, 房间号必须唯一
    
    1. [ ] roomid中可以反推出serverid
    2. [X] gameRoom中记录serverid
       暂时使用这个方案

    遗留问题:
    1. 修改房间流程的时候, 需要使用第一种方案;
       因为现在是由lobby给game分配roomid, 
       之后game之间不互通, 只能使用方案1
** DONE frame与sub分离
   CLOSED: [2019-08-05 Mon 14:25]
   - [2019-08-05 Mon] [done]
*** msg
    1. frame: NetMsg.decode时候保留原始数据
    2. frame: handleMsg的时候转发给sub
    3. sub: 把原始数据转为具体的结构体
*** 流程
*** 数据    
** TODO 房卡场, 金币场, 俱乐部
*** 消息号
    1. 房卡场 | 俱乐部
       创建: C2M_PYQ_PLAYER_CREATE_ROOM_SYN
       加入: C2M_PYQ_PLAYER_REQ_ENTER_ROOM_SYN
    2. 金币场
       server查询请求 --
       创建 | 加入  C2L_REQUEST_ENTER_GOLD_ROOM
       [[file:~/code/company/SystemModule/LobbyServer/HandlerFromGate.cpp::OnMSG_C2L_REQUEST_ENTER_GOLD_ROOM_SYN][C2L_REQUEST_TNTER_GOLD_ROOM]]
*** 创建流程                                                      :TODOLATER:
    1. client向lobby发起请求
    2. lobby自己创建房间 -- 生成roomid, 并记录对应的serverid
    3. 如果是new room, 通知DB记录
    4. [[file:~/code/company/SystemModule/LobbyServer/HandlerFromDB.cpp::D2L_WRITE_ROOM_INFO][DB返回给lobby, lobby通知game]] 
    5. [[file:~/code/company/SystemModule/GameServer/HandlerFromLobby.cpp::OnMSG_L2M_PYQ_PLAYER_CREATE_ROOM_SYN][game创建完房间, 通知lobby]]
    6. [[file:~/code/company/SystemModule/LobbyServer/HandlerFromGame.cpp::OnMSG_M2L_PYQ_PLAYER_CREATE_ROOM_ACK][lobby通知client]]
    7. client连接game
    8. game向lobby确认
    9. lobby返回确认结果给game
    10. game通知client, lobby

    遗留问题:
    1. 流程修改为: game中先创建room, lobby映射 && 写入数据库
    2. 函数命名修改: 金币场的流程使用了之前房卡场的流程, 需要修改函数的命名
    3. Lobby/GoldRoomManager这个类应该删除
    4. Lobby/GameRoom 删除无用数据
*** 加入流程
    1. client向lobby发起请求
    2. lobby返回给client
    3. client连接game
    4. game向client确认
    5. client返回确认结果给game
    6. game通知client, lobby
*** 遗留问题
    遗留问题
    1. 推荐房间.
       之前逻辑: 金币房预创建, 所以这里可以显示
       替代方案: lobby给client虚拟数据(room还未创建), client点击时, lobby将已坐椅子数传递给game;
                 game根据已做椅子数 创建机器人.
       胡总方案: game中的机器人创建room (2019.8.6 15:30)
    2. 因为暂时无机器人, 测试模拟房卡场

    需要优化:
    1. lobby, gmae创建房间的流程
    2. 房间规则  -- 来源与流程

** TODO 比赛场                                                    :TODOLATER:
*** 消息号
    加入  C2L_MATCH_APPLY
*** 主要类
    1. match_manager管理 比赛场列表
    2. match_item表示一个比赛场, 管理比赛场房间
    3. match_room表示某个比赛场的某个房间
       
*** 房间生成方式
    GameCtrl::Run()中向DB查询所有比赛信息,
    match_manager::on_read_match_config()中创建match_item信息,
    并为每一个match_item创建一个match_rom, 当做wait_room, 等候区
    当wait_room人满之后, wait_room变为正常的match_room; 然后生成一个新的wait_room
    
    注: wait_room与match_room没有本质上的区别, 只是为了逻辑上比较清晰处理

    TODONOW 待确认: 比赛场中的GameServer的roomid生成是否符合条件

*** 加入流程
    client --> lobby  --> game --> lobby --> client
    lobby随机选择一个GameServer,  并通知该GameServer
    GameServer 返回roomid等信息 给lobby
    lobby根据roomID找到ServerID, 从而找到GameServer信息
    然后lobby通知client

   已有问题:
   1. 比赛场 同一个kind能否开多个GameMatchServer
      考虑因素: 比赛场中所有桌子上的人需要一起比较数据, 如果不在同一个ServerID上, 则会出现问题
      替代方案: 比赛场有多种模式, 同一个Kind下同一个模式, 只能在同一个Server上	  
      方案结果: 不能; 一个kind上只能有一个GameMatchServer
      结    论: 一个kind只能开一个GameMatchServer
   
** 战绩记录 && 录像回放
   [[file:~/code/company/SystemModule/DBProxyServer/HandlerFromGame.cpp::OnMSG_L2D_WRITE_GAME_RECORD][MSG_M2L_GAME_RECORD]] -- 写入数据库, [战绩,回放]一起写入了

   [[file:~/code/company/SystemModule/DBProxyServer/HandlerFromGame.cpp::OnMSG_L2D_READ_PLAYER_COMBAT_GAINS][D2L_PLAYER_COMBAT_GAINS]] -- 战绩记录 查询
   [[file:~/code/company/SystemModule/LobbyServer/HandlerFromDB.cpp::OnMSG_D2L_GAME_REPLAY][MSG_D2L_GAME_REPLAY]]     -- 录像回 放查询

   
   总结:
   1. MSG_M2L_GAME_RECORD   
      消息号在frame定义,
      结构体定义在frame中

   2. MSG_L2C_GAME_REPLAY   
      消息号在frame定义，
      结构体定义在subgame中, 各个subgame结构体不同


   场景模拟
   1. 小局结束, subgame将结构体发送给frame, frame转发给DB 存储
      1) 结构体定义在subgame的message.proto中, 但是没必要定义消息号; 
      2) frame中定义消息号; 但是没法定义结构体(各个子游戏不同); 所以frmae中必须定义一个通用的泛结构体

   2. DB写入; DB会获取泛数据, 不认识的数据会直接写入


   
   1. client向lobby发送录像回放
      1) frmae中定义了查询消息号, 查询结构体; 

   2. lobby收到之后去DB查询

   3. 将数据原封不动的发送给client
      1) frame中定义了消息号, 并返回给client泛数据

   4. client收到数据后, 转发给具体的子游戏
      1) 子游戏处理函数中, 把泛型转换为具体数据;  子游戏的message.proto中有具体结构体定义 


   遗留问题
   1. 根据roomid 查询房间号 --> 不同时刻可能会有多个房间号
   2. 删除replay_id的查询方式  
*** 需要处理
    1. 战绩记录查询
       查询不到数据, 需要再确认下
       
    2. 录像回放 -- 数据序列化问题
       1) 数据传输到DB
       2) 序列化方法         
         
** 机器人
   target
   1. 查看现有机器人功能
   2. 多游戏支持下的新实现
*** 设计思路
    basic:
    1. 机器人与lobby没有任何关系, 只在game中出现
    2. 机器人使用playermanager类管理, 字段区分玩家和机器人
    3. 机器人子游戏逻辑调用托管逻辑, 不需要重新写
*** RobotManager初始化
    1. [[file:~/code/company/SystemModule/GameServer/GameCtrl.cpp::InitRobot()][gameserver启动时候, 根据robot.cfg中的机器人数目向lobby请求初始化机器人]]
       请求内容
       1) 机器人配置信息
       2) 机器人玩家
    2. lobby向db做出查询
    3. db查询并返回所有的机器人给lobby
    4. lobby通知game
*** GameRoom初始化机器人
    1. GameRoom中根据房间椅子数生成robot rand数目
    2. [[file:~/code/company/SystemModule/AICode/RobotManager.cpp::SendLobbyGetRobot][RobotManager在初始化机器人的时候, 开启了定时器, 用来控制机器人进出房间]]
    3. 在定时器中控制了机器人是否加入还是离开房间

*** 遗留问题
    1. [X] 为什么区分占桌机器人和陪玩机器人??
       站桌机器人: GameRoom初始化时候, rand的 robot
       陪玩机器人: 因为rand的数目是随机的, 所以即使有真人玩家坐下, 也未必人满; 这时候来检测, 并分配机器人
       结论:
       1) 站桌机器人由GameRoom自行处理
       2) 陪玩机器人, 可以检测
    2. [X] 站桌机器人是否需要定时器处理
       没必要理由:
       1) 效率太低
       2) GameRoom初始化时候, 可以主动安排机器人入座; 更符合逻辑习惯
       存在理由:
       1) 担心初始化失败? 是否存在这种情形, 即使存在, 也不需要在这里进行判断
       结论:
       不需要这样处理
    3. [ ] 如果保留RobotManager, 那么RobotManager也应该是继承PlayerManager

*** 修改范围
    1. GameRoomManager移动到GameServer
    2. Robot 逻辑移动到 subgame, 在subgame中设计接口
    3. 优化部分函数
** GameRoom
*** player与gameroom交互
    1. 加入房间
       设置RoomID
       初始化椅子位置 TablePosId -1 // TODONOW 如果这个之后会kick out玩家, 那么是否有问题
    2. 坐下
       设置椅子位置 TablePosId
       设置玩家状态 USER_STATE_SIT_DOWN
   3. 准备
      设置准备状态SetPlayerReadyStatus(true)
      设置玩家状态 USER_STATE_READY
   4. 起立
      设置椅子位置 TablePosId -1   TODONOW wait for lobby ack leave room
      设置玩家状态 USER_STATE_IN_GAME
      设置准备状态 SetPlayerReadyStatus(false)
   5. 离开
      设置椅子位置 TablePosId -1 
      PlayerManager::Instance中删除玩家

** sub框架整理
** 乱七八糟
*** 远端服务器
    外网Centos服务器
    外网IP: 47.103.90.189
    SSH:    47.103.90.189     root     eHbQC&LV8p      
    MYSQL:  47.103.90.189     root     &rXM6!03$P
*** Msg数据包
    0   [<- pBuffer
    1
    2
    3
    4   ] <-[]包的大小 [0-n]-4; 不包含int
    .   {[
    .
    .    ] <-[]值为 htonll(m_UID)
    .    [
    .
    .   }] <-[]值为htonll(m_sinAddr)     {}--HeadMsg
    .   {[
    .
    .    ] <-[]值为ntohl(m_nMSgID) long 
    .    [
    .
    .    ] <-[]值为ntoll(m_Token)
    .    [
    .
    n   }] <-[]值为MsgBody                {}--NetMSg

    遗留问题:
    1. 数据没有加密
*** 常用enum
    1. 登录错误处理
       enum KICK_CLIENT_REASON
       {
       CLIENT_REPEAT_LOGIN = 0,      //重复登录
       CLIENT_TOKEN_EXPIRE = 1,      //
       CLIENT_SYSTEM_ERROR = 2,      //系统错误
       CLIENT_ROOM_NOT_FOUND = 3,    //没找到房间
       CLIENT_ROOM_FULL = 4,         //房间已满
       CLIENT_ROOM_LIMIT = 5,        //房间限制
       CLIEN T_ROOM_DISMISS = 6,      //房间已解散
       CLIENT_LEAVE_ROOM = 7,        //离开房间???
       CLIENT_CLEAN_TABLE = 8,       //清空桌子???
       CLIENT_ROOM_TIME_OUT = 9,     //房间超时????
       CLIENT_ROOM_BEGIN_DISSOLVE = 10, //房间开始表决解散
       CLIENT_MATCH_PLAYER_RANK = 11,    //
       CLIENT_MATCH_PLAYERNUM_ERROR = 12,  //人数错误
       CLIENT_MATCH_WAIT_LEAVE = 13,       //等待离开
       }
    2. 桌子状态
       enum ROOM_STATE 
       {
       ROOM_STATE_INIT = 0,            //table初始化
       ROOM_STATE_WAIT_CREATE = 1,     //等待创建 -- 因为table是在[game,lobby]完全交互完成后,再创建的
       //ROOM_STATE_CREATED = 2,         //创建完成  -- 无意义
         ROOM_WAIT_START = 3,            //等待开始  
       ROOM_STATE_ROUND_GAME_START = 4,//小局开始
       //ROOM_STATE_PLAYING = 5,         //正在进行 -- 这个无意义; 小局结束之前 都是正在进行
       ROOM_STATE_ROUND_GAME_END = 6,  //小局结束
       ROOM_STATE_GAME_ALL_END = 7,    //大局结束
       }
    3. 玩家状态 TODONOW 玩家加入|离开房间, 没有状态
       enum USER_STATE 
       {
       USER_STATE_INIT = 0,            //
       USER_STATE_IN_LOBBY = 1,        //在大厅
       USER_STATE_WAIT_IN_GAME = 2,    //等待进入GameServer?
       USER_STATE_IN_GAME = 3,         //在GameServer
       USER_STATE_SIT_DOWN = 4,        //坐下
       USER_STATE_READY = 5,           //准备
       USER_STATE_PLAYING = 6,         //游戏中
       USER_STATE_WAIT_START = 7,      //等待开始
       USER_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
       USER_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
       }
    4. 游戏类型
       gametypeid
       1 -- 金币场
       2 -- 房卡场
       3 -- 比赛场
** bug处理
   1. [X] sub正常打牌, 服务器崩溃在protobuf的函数中
      偶然出现, 基本必出(游戏局数增加之后)
      1) 崩溃在frame的MessagePareser->的FetchMessage()中的Clear()
      2) 崩溃在sub的protobuf的add()函数中

      影响因素:
      1. protobuf在智能指针中的使用
      2. 动态库的影响
      3. 2份protobuf文件, 导致的命名重合

      最终结论:
      1. protobuf::Message的使用问题, 需要单独为之分配内存再使用;
      2. TODOLATER 怀疑protobuf:Message自己有分配内存, 具体情况需要再查看资料
** 游戏性能测试
   20%的代码决定了80%的性能
** 底层接口
   1. [[file:~/code/company/SystemModule/BaseCode/EventLoop.cpp::ProcessEventsAndTimers][EventLoop 事件循环监听]]
      1) 维护了epoll对象
      2) socket接口封装
      3) Connection管理

      处理流程:
      1) 由EventTimermanager获取到当前时间 对应的 timer
      2) 由epoll 判断是否有事件, 没有则退出
      3) 如果有事件(可能是多个事件,由m_eli.nMaxConnPerEvent控制), 则执行事件操作(read write)
      4) 循环检测: 不管timer有无events, 都会删除过去的timer
      5) 循环检测: 删除失效的socket连接
   2. Timermanager 获取时间
      m_mstm =  (unsigned long)(m_tmval.tv_sec * 1000 + m_tmval.tv_usec / 1000);
      因为m_tmval.tv_usec为毫秒, 取值为[0-999], 所以m_tmval.tv_usec / 1000 其实是舍弃了毫秒
      所以这个函数获取的时间是秒级别的
   3. EventTimermanager
      维护了一个红黑树
   4. Eventchannel
      epoll的单个事件处理
   5. EventCallback
      接口类, 在Eventchannel中被调用;
      分别被Accetp, Connector和Connection实现
   6. Accept
      socket的server端
      内部使用原生socket接口实现
   7. Connector
      socket的client端
      内部使用原生socket接口实现
      自己是client, 向server连接
      比如lobby向DB连接;  Game向lobby连接时候 调用该类
   8. Connection
      client socket类
      Connection与socketID一一绑定
   9. Connectionmanager
      Connection的管理类
   10. OnMessagecallback -- 函数指针
   11. Circuitqueue
       数据收发 中间层
*** 流程
    1. Server连接其他server时候, 调用Connector类, 并在epoll(EventLoop)中记录, 然后循环检测时处理;
    2. client连接server
       1) Server中调用Accept类, 开启socket listen; 
       2) 有client连接时, 在epoll中记录, 并把sockt::accept转给对应的Connection的GetAcceptCallback;
	  GetAcceptcallback返回的是函数指针;
	  函数指针在server中可自行注册;
	  比如, GameServer中:
	  [[file:~/code/company/SystemModule/GameServer/GameCtrl.cpp::IncomingAcceptCallback][此处注册了函数指针]](由EventLoop->ConnectionManager, 再传递给Connection)    
*** 遗留问题
    1. [ ] m_eli.nMaxConnPerEvent 在哪里赋值的
    2. [ ] 如果timer的events没有在1s内处理完成, 就会被删除
    3. [ ] 红黑树
    4. [X] epoll -- 处理socket连接使用
** DB多线程
   关注点
   进程中 _公共内存_ (static, 全局数据)的 _写操作_
*** 流程   
    1. DBServer初始化DBProxyCtrl, Ctrl中初始化线程
    2. 线程[[file:~/code/company/SystemModule/BaseCode/Thread.cpp::void*%20ThreadProc(%20void%20*pvArgs%20)][启动函数]]中连接数据库, 并执行run()
    3. [[file:~/code/company/SystemModule/DBProxyServer/DBProxyCtrl.cpp::DBProxyCtrl::TransferOneCode][DBProxyCtrl中收到数据校验后, 执行dbhandle线程的GetOneCode]]
    4. 线程的run()函数中, 检测到GetOneCode结果变动后, 解析msg, 并交给PacketHandler执行

*** 遗留问题

** 金币场配置从数据库获取
** 进程管理工程
   写一个工具, 完成以下功能:
   target
   1. 监控各个程序 
      1) cpu, mem等系统资源
      2) 错误信息
   2. 配置 && 启动 && 关闭
   3. 重载Server进程输出
      放到最后实现, 正式服务器上是没有这个的
*** 设计思路
    1. 需不需要ui界面
       结论: 使用字符界面
       1) 运行环境 -- linux server, 无gui
       2) 也没有必要使用gui, 使用字符界面即可
    2. 需要的功能
       1) 配置信息展示
	  1. Ui界面类
	  2. 读写config
       2) 错误展示
	  1. Ui界面类
	  2. 监控log文件 或者 是server告之
	  3. log文件
       3) 监控信息
	  1. Ui界面类
	  2. 内存信息读取
	  3. log文件
       4) 启动, 关闭
	  1. UI界面类
	  2. 调用shell脚本 -- 这个最简单
    3. 界面设计
       1) 配置信息展示 界面
	  程序没启动时候, 显示这个window
	  1) 主要信息显示
	  2) 启动, 关闭程序的功能
	  3) 配置信息修改功能
	  4) 一键跳转到配置文件位置
       2) 监控信息
	  程序运行时候, 显示这个window
	  1) 程序运行状况 -- cpu, 内存一览
	  2) 程序错误日志 显示 -- 滚动翻页 -- log日志
	  3) 关闭, 启动功能
       3) 重载程序的输出

*** 需要的类
    1. [X] Ui界面
       ncurses实现
       1) 总体显示类
       2) Table显示类
    2. [X] CCfg
       fstream + string实现
       完成config文件的读写操作        
    3. [X] Clog
       记录log文件
    4. [X] shell交互
       1) system()
          启动子进程处理, 调用完毕, 返回到当前进程, 并获得shell是否执行成功的int结果
       2) exec() 
          使用当前进程处理, 本程序失效, 进入调用程序
       3) popen()
	  启动子进程处理, 并获得shell的输出;
	  shell的输出将保存到FILE* 中
    5. [ ] 内存信息读取类
    6. [ ] ??监控log文件 或者 server告之

*** 使用的技术
    1. ui table界面显示的时候, 使用线程处理.
       更准确的说, 启用3个不同的线程, 分别处理三种信息的展示

** kwx工程同步
*** subgame同步
    1. 移动GameRoom.* && *Mahjong* 到新的目录SubGame_kwx
    2. copy SubGame_hh中的GameRoomSink.* && Makefile 到SubGame_kwx
    3. 逻辑修改
       
*** 大厅同步

** poker框架
   1. GameRoomSink接口适配
   2. 部分function;  win->linux
   3. 配置文件读取
   4. log日志接口
   5. robot处理

** frame框架 v0.2
   1. log接口
   2. cfg接口

** 缺陷
   1. 因为pid文件的存在, 导致无法开启多进程
      难点:
      1) 如果不使用pid, 又如何知道 server -- kinid的关系?
	 
      解决方案:
      1) 启动一个新的管理进程, 来通知server 应该关闭
	 管理进程 -- 选择kind + node
	 通知哪个server?  是不是需要注册一下? 或者在lobby中获取?
	 通知到该server之后, server应该怎么处理?

	 无法通过调用kill()函数退出, 因为不知道pid
	 可以通过退出while(1)循环, 来保证server的退出
	 
	 
